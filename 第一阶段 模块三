一、Object
（一）API
API：Application Programming Interface，应用程序编程接口
接口：用于规定方法名称的规则的集合。定义方法名称、修饰符、返回值类型、参数列表、方法功能等。
实际：应用程序编程接口，也包含了Java中的接口、类、枚举以及他们其中的方法
学习中，更多侧重于基本的使用，以及一些底层原理，这些内容不需要我们自己去定义，只需要我们调用
（二）类库
Java 代码编译之后会生成.class文件，.class文件包含了代码中所有的内容，Java程序执行时会执行.class文件，就算没有了源代码，.class文件也能够照常使用
（三）Object 概述
Object是所有类型的顶层父类，是所有类的直接或者间接的父类，所有类型中，都可以使用 Object 类型的方法
随意定义一个Java类型，不显式表示继承哪个类型，都会默认继承Object类
Object类型的构造方法：
(1) 用于自己创建对象
(2) 用于让子类的构造来访问
(3) Object类型创建对象时，Object的构造不会再访问别的类型的构造，因为它就是顶层了，它没有父类了
（四）toString 方法
getClass() 获取到当前对象所属的类型
hashCode() 根据对象的情况，计算出对象的哈希码值
toString() 返回对象的字符串表示形式
推导过程：
(1) 我们直接打印一个自定义类型的对象，打印的是对象的地址值
(2) 我们通过对象调用继承而来的toString()方法打印而来的还是对象的地址值
(3) 在Object类中，toString()方法确实是在计算并且返回对象的地址，计算公式：
getClass().getName() + “@” + Integer.toHexString(hashCode())
(4) 我们通过(1)和(2)得到，直接打印对象的声明引用，会自动调用Object类中的toString()方法，得到地址
(5) 但是我们作为人类，不需要地址值，拿到也没用
(6) 结合方法重写前使用父类的方法，重写后使用子类的方法，我们在子类中重写toStirng要求返回对象的属性值
(7) 在子类中重写toString()方法后，打印的就是对象的属性值
重写的原则：不要返回地址值，返回属性值
最终操作：我们可以自动生成重写:alt + shift + s S
如果以后要打印一个对象，先要显示对象的属性值而非地址值，就要在对象所属的类型中重写toString()方法，让其返回属性值而非地址值
（五）equals 方法
用于比较两个对象是否相等。这两个对象分别为：调用这对象，参数对象
在 Object 类型中，比较的是两个对象的地址值是否一致
实际上，计较两个对象的地址不具有太多的意义，我们更希望比较对象的属性值来判断对象是否相等，我们就需要在对象所属类型中重写 equals 方法
快捷键：alt + shift + s H
（六）== 和 equals 的区别
共同点：都是用于比较数据是否相等的方式
不同点：
（1）== 是运算符，equals 是方法
（2）比较的内容不同：== 既可以是基本数据类型，也可以是比较引用数据类型；equals 只能比较引用数据类型
（3）比较规则不同：== 比较基本数据类型，比较值；比较引用数据类型，比较地址；equals 中些钱比较地址，重写后比较值

二、Scanner 类型
（一）概述
Scanner 类型是一个可以扫描基本类型和字符串的简单文本扫描器，可以指定扫描设备
构造方法：
(1) Scanner(File source) 扫描指定的文件
(2) Scanner(String source) 扫描指定的字符串
(3) Scanner(InputStream source) 扫描指定的输入流
其中，我们使用过第三个构造方法， Scanner(System.in) ，其中 System.in 就是一个输入流，标准输入流，默认关联到键盘
扫描器可以解析节本数据类型和字符串
（二）录入基本数据类型
方法：
(1) nextByte()
(2) nextShort()
(3) nextInt()
(4) nextLong()
(5) nextFloat()
(6) nextDouble()
(7) nextBoolean()
注意事项：
(1) 没有nextChar()方法
(2) 键盘录入时要符合数据类型的取值范围
(3) 当录入float数据的时候，没有必要加F，因为键盘录入的内容，不属于Java代码
(4) 多个数据同时录入的时候，每个数据之间用空格也可以作为结束标志
（三）录入字符串
方法：
(1) next()：可以将空格作为分隔标记
(2) nextLine()：通过换行来作为结束标记
（四）Scanner 类型的小问题以及避免方式
问题：当我们使用了可以一空格作为分隔和结束标志的方法后，在紧接着使用 nextLine()方法， nextLine() 会直接被消耗掉
解决办法：
(1) 创建两个Scanner对象，新的Scanner上次没有录入数据，内部是干净的，用来录入第二个数据
(2) 连续调用两次nextLine方法，第一个消耗掉对象中剩余的内容，第二个等待重新录入
(3) 所有录入的内容都是用nextLine方法，之后将字符串表示形式的数据再解析为数据本身所对应的类型
三、String 类型
（一）概述
String 类型表示字符串，属于 java.lang 包，不用导包
所有的字符串常量（“abc”）也是 String 类型的对象
字符串字面值常量，存储在方法取得常量池中
String 类型表示的字符串本身是一个常量，创建后就无法修改（不可变字符序列）
不可变的原因：String 没有提供任何的 set 方法能够修改字符串本身
（二）构造方法
String() 创建一个空字符串
String(byte[] arr, int offset, int length) 将byte数组的一部分解析为字符串
String(char[] arr, int offset, int length) 将char数组的一部分解析为字符串
String(String str) 返回参数字符串的副本
（三）String 类型的判断功能
equals(Object obj) 判断调用者字符串和参数字符串内容是否相等
equalslgnoreCase(String anotherString) 忽略大小写判断调用者和参数字符串内容是否相等
contains(String str) 判断参数字符串是否为调用者字符串的字符串
startWith(String str) 判断调用者是否为参数字符串开头
endWith(String str) 判断调用者是否为参数字符串结尾
isEmpty() 判断调用者是否为空串
（四）String 类型的获取功能
length() 返回调用者字符串的长度
char(int index) 从调用者字符串上获取到指定索引的字符返回
substring(int beginIndex) 从指定索引开始，截取调用者字符串的一部分，知道字符串结尾
substring(int beginIndex, int endIndex) 截取调用者字符串的任意一部分,范围：前包后不包
indexOf 重载：
(1) indexOf(int ch) 顺序查找指定字符第一次出现的索引
(2) indexOf(int ch, int fromIndex) 从指定位置开始顺序查找指定字符的索引
(3) indexOf(String str) 顺序查找指定字符串第一次出现的索引
(4) indexOf(String str int fromIndex) 从指定位置开始顺序查找指定字符串的索引
lastdexOf 重载：和 indexOf 相反
（五）String 类型的转换功能
byte[] getBytes() 将调用字符串转为 byte 数组
char[] toCharArray() 将调用者字符串转为对应的字符数组
toUpperCase() 将字符串转为纯大写
toLowerCase() 将字符串转为纯小写
concat(String str) 将参数字符串追加到调用者字符串之后（拼串）
ValueOf 重载：都是静态方法，用于将其它数据类型转换为 String 类型

System类
用于描述系统资源的类型，不能创建对象。类中的方法都是静态的，使用类明直接调用
常用字段：
（1）System.out 标准输出流，默认关联显示器
（2）System.in 标准输入流，默认关联键盘
（3）System.err 错误打印流默认关联到显示器，用于打印错误的信息
常用方法：
（1）gc() 运行垃圾回收器
（2）currentTimeMills() 获取时间的毫秒值。1000ms = 1s，表示从1970年1月1日0时0分0秒开始发哦方法执行的时间。
二、StringBuilder 类
（一）概述
StringBuilder 是一个可变字符序列。因为在类中，提供了修改字符串的成员方法，常用方法是 append 和 insert ，就是在StringBuilder 本身上，进行修改操作。
StringBuilder 底层维护了一个字符数组，数组是私有的，外界无法访问，因此在StringBuilder 或者String 中封装了对底层操作的公有方法
String 和 StringBuilder 的区别：
（1）String 是不可变字符序列，没有提供任何的修改其本身的方法，StringBuilder 是可变字符序列，提供了修改自身的额方法
（2）String 本身长度也不可变，StringBuilder 长度可变，通常我们将StringBuilder 当做是一个长度可变的容器，用于存储字符
（二）构造方法
构造方法的作用：创建当前对象，将其他数据转换为当前类型
构造方法：
（1）StringBuilder() 创建一个字符串生成器，初始容量为16
（2）StringBuilder(int capacity) 创建一个字符串生成器，初始容量有 capacity 指定
（3）StringBuilder(String str) 创建一个字符串生成器，初始化参数字符串。初始容量为16 + 字符串长度
获取容积的方法：
（1）capacity() 返回字符串生成器的容量
（2）length() 返回字符串缓冲区中的字符个数
（三）添加功能
append（任意类型）
（1）作用：将当前字符个数追加到当前可变字符序列之后
（2）底层操作：将当前字符个数和当前数组容积进行比较，如果溢出，就做数组拷贝，将原数组的内容添加到新数组中，其中，新数组的容积是原数组容积<<1+2。所以，数组自动增大实际上是数组的拷贝
insert(int index, 任意数据类型) 可以将任意数据类型插入到指定位置
（四）删除功能
deleteCharAt(int index) 删除字符串缓冲区中指定索引上的字符串
delete(int start,int end) 删除字符串缓冲区上一段字符串
（五）替换和反转功能
replace(int start,int end, String str) 使用指定字符串去替换字符串缓冲区种植钉的字符串
reverse() 反转字符串缓冲区
（八）StringBuilder 和 StringBuffer 的区别
共同点：都是可变字符序列，都是字符串生成器，都是字符串缓冲区
不同点：
(1) 线程安全性不同：
①StringBuilder是线程不安全的，多线程环境下无法保证数据安全
②StringBuffer是线程安全的，多线程环境下依然可以保证数据安全
(2) 效率不同：
①StringBuilder效率高
② StringBuffer效率低
(3) 版本不同：
①StringBuilder出现在JDK5
②StringBuffer出现在JDK1.0
三、基本数据类型包装类
（一）概述
基本数据类型有八中，都是简单的数据类型
在这些基本数据类型中，只能表示简单的数据，不能包含一些操作数据的方法，并且也不是对象，所有的逻辑都需要自己定义，比较麻烦。将基本数据类型封装，形成一个Java类，类中还提供了操作基本数据类型的一些方法，以及将基本数据类型和其他数据进行转换的方法。
基本数据类型包装类：
在这里插入图片描述

（二）Integer 类型
各种基本数据类型包装类，方法、特点基本相同。只需要学一个 Integer 其它的都能狗操作了
integer 类型的对象中，维护了一个私有的成员变量，是一个 int 字段，用于表示这个 Integer 对象想要表示的数字
提供了在 int、 Integer 、String 之间相互转化的功能
提供了一些常量
（三）Integer 类型的字段
常量值：
（1）MAX_VALUE：int 类型的最大值
（2）MIN_VALUE：int 类型的最小值
（四）Integer 类型的构造方法
Integer(int value) 将 int 值包装成一个 Integer 对象
Integer(String s) 将 String 类型的数字转为 Integer 对象
（五）Integer 类型的成员方法
xxxValue() ：可以将 Integer 对象转化为各种基本数据类型的数字类型
toString() 将 Integer 对象转化为 String
静态方法：
(1) parseInt(String s) 将 String 转为 int
(2) parseInt(String s, int radix) 将第一个参数当做第二个参数指定的进制，结果产出一个十进制
(3) toBinaryString(int i) 将参数作为十进制，结果是一个二进制的字符串表示形式
(4) toOctalString(int i) 将参数作为十进制，结果是一个八进制的字符串表示形式
(5) toHexString(int i) 将参数作为十进制，结果是一个十六进制的字符串表示形式
(6) valueOf(int i) 将参数int转为Integer对象
（六）自动拆装箱（JDK5）
装箱和拆箱
(1) 装箱：将基本数据类型，封装成包装类的对象，这个过程就是装箱。
(2) 拆箱：将包装类对象中的基本数据类型解析出来，就是拆箱。
自动拆装箱
(1) 自动装箱：可以直接使用基本数据类型的数据，给引用数据类型赋值
(2) 自动拆箱：可以直接使用基本数据类型包装类的对象，给基本数据类型赋值，或者直接参与运算

一、正则表达式
（一）概述
就是一个字符串（regex）
作用：不仅表示一个字符换，还可以表示一类字符串，表示一类字符串的格式或者规则
好处：可以使用特别简单的代码，表示非常复杂的逻辑
坏处：很难写出正确的正则
（二）正则表达式的好处
需求：键盘录入一个字符串，判定这个字符串是否为一个合法的QQ号
合法QQ的条件：必须全是数字；必须在5-15位；0不能开头

（三）正则表达式的字符类
普通的字符串也是一个正则表达式，但是只能表示他自己
判断某个字符串是否和某个正则表达式匹配，需要使用String类中的matches方法
字符类型：表示单个字符，使用符号[]，只要使用了[]，无论里面写多少内容 ，都表示单个字符，只是允许出现[]里面内容的其中之一

（四）正则表达式的预定义字符类
有一些字符经常使用，所以就提前在正则表达式中进行了定义，称为预定义字符类
预定义字符中的\不是转义字符，就是一个普通的反斜杠，例如：\d，就是一个整体，而不是通过转义字符转换了d原本的含义，所以在Java代码中书写的时候要写成【\d】
预定义字符也仅仅表示单个位置
预定义字符中的【.】表示任意字符，如果在代码中直接书写【.】，就是通配，如果想要表示普通的点，必须写成【\.】

（五）数量词
无论字符类还是预定义字符类，都只能表示单个位置的字符，如果想要表示没有或者多个位置的字符，就需要借助数量词来实现
注意事项：数量词只能修饰左侧紧挨着它的那一个位置的字符
分类：
(1) 模糊数量词：X?、X*、X+
(2) 精确数量词：{n}、{n, }、{n, m}


二、Date类
该类的对象用于表示一个特定的瞬间，精确到毫秒值，根据调用的构造方法不同，能表示不同的瞬间
构造方法：
(1) Date() 表示创建对象刹那的时间
(2) Date(long date) 表示传入毫秒值的时间，是从1970年1月1日0时0分0秒起开始计算
成员方法：
(1) getTime() 获取Date对象表示的时间的毫秒值
(2) setTime(long time) 将调用者对象的毫秒值设置为指定值

三、DateFormat类
直接打印Date对象得到的日期格式不好阅读，我们需要一个能够对时间进行格式化的对象，将Date表示的时间格式化为我们便于阅读的格式
DateFormat是个抽象类，不能创建对象，将来使用其子类穿件对象，有一个已知子类：SimpleDateFormat
DateFormat在text包下，需要导包
重要成员方法：
（1）Format(Date date) 将参数对象，格式化为一定的日期格式，结果是一个字符串 Date -> String
（2）parse(String date) 将参数字符串表示的时间解析为一个Date对象 String -> Date
四、SimpleDateFormat
一）simpleDateFormat的使用
DateFormat是一个抽象类无法实例化，所以使用其子类创建对象，并且调用方法，使用SimpleDateFormat类型，可以使用DateFormat类中的所有方法
构造方法：
(1) SimpleDateFormat() 使用默认的格式解析时间对象，默认格式：20-11-4 下午3:00
(2) SimpleDateFormat(String pattern) 使用给定的格式解析时间对象
五、Calendar类
（一）概述
表示一个精确的瞬间，包含了非常多的日历字段
在 util 包下，需要导包
Calendar 类是抽象类，不能创建对象，解决：
(1) 直接使用子类创建对象
(2) 调用静态成员方法，返回实现子类对象
获取 Calendar 类是抽象类的对象方式：
Calendar.getInstance()：可以获取到Calendar的实现对象，此对象获取到的时候，就包含了所有的日历字段
常用方法：
(1) get、set方法用于给对象时间赋值
(2) add方法可一给对象的某个字段值增加时间
(3) getTimeMillis获取对象中的时间毫秒
（二）get 方法
直接打印Calendar对象，可以展示所有的字段值，需要获取某个确定的字段值，就需要使用get方法
get(int field) 传入字段序号，可以返回具体的字段值
注意事项：
(1) 月份是0-11，所以月份获取到以后要+1
(2) 星期是从星期天开始，所以获取到序号要-1
（三）set 方法
可以针对具体的日历字段对应的设置值
方法：
(1) set(int field, int value) 指定日历字段，设置为指定的值
(2) set(int year, int month, int date, int hourOfDay, int minute, int second) 设定Calendar对象的年月日时分秒字段的值，其余字段值保持不变
注意：set 方法只会修改制定字段，没有被指定的字段值保持不变
（四）add 方法
方法功能：在某个日历字段现有的时间基础上，添加一些时间，让时间进行偏移
注意事项：如果当前时间不够存储偏移的时间，会自动按照时间的规则向上进

一、Math
两个常量：
（1）E：自然对数的底数：2.718
（2）PI：圆周率：3.1415926
常用方法：
（1）abs(数字类型) 求绝对值
（2）cbrt(double d) 开立方
（3）sqrt(double d) 开平方
（4）ceil(double d) 向上取整
（5）floor(double d) 向下取整
（6）max(int a, int b) 求最大值
（7）min(int a, int b) 求最小值
（8）pow(int a, int b) 求 a 的 b 次方
（9）random() 返回 [0.0, 1.0) 的随机数
（10）round(double d) 四舍五入，负数部分可以看成“五舍六入”
二、集合概述
（一）对象类型的数组
定义一个数组，里面存储的都是某个类型的对象，对象时引用数据类型，所以数组中存储的是这些对象的地址值；
集合：也是一个类似数组的统一存储、管理数据的容器，集合只能存储引用数据类型，不能存储基本数据类型，就好像是对象数组
（二）集合的由来
对象数组的不足：
（1）无法扩展：数组本身长度固定，一旦创建无法更改
（2）结构：每次要添加一个新的元素，都需要创建一个更大的新数组，将原数组的内容填入新数组，并且填入新加入的元素，长此以往非常麻烦。并且这些操作和我们实际开发中的业务逻辑并不相关
（3）所有关于数组操作的业务逻辑都需要自己去定义，并且自己定义的操作还不全面
集合的优势：
（1）可扩展：底层会自动增长，不用我们主动操作进行扩展，避免了不必要的麻烦
（2）集合中定义了大量的操作集合的方法，这些方法还十分易用，为我们操作集合提供了便利
（3）集合存储的全是引用数据类型，及对象，也利于我们面向对象的编程思想
（4）不带泛型的集合可以存储各种类型的数据
（三）集合和数组的区别
共同点：
（1）都是用于存储和管理数据的容器
（2）零散的变量不便于操作和存储，使用一个容器统一管理，容器都具有索引或者类似索引的标志，便于查找和管理数据
不同点：
（1）存储内容不同：
a、数组既能够存储基本数据类型，也能存储引用数据类型
b、集合只能存储引用数据类型，就算添加的时候是基本数据类型，存储在集合中也是基本数据类型的包装类的对象
（2）存储数量不同：
a、数组创建出来之后，大小不可变，数组容量有多大，就能存储多少数据
b、集合底层可以自动增长，容量可变
（3）方法不同：
a、数据只能使用Object类型的方法和一个 length
b、集合中有大量易用的方法
（四）集合的体系结构
集合分类：
（1）单列集合：每一个元素都是一个单独的个体，就类似数组一样
（2）双列集合：每个操作都针对一对数据进行，以一堆数据为单位

三、Collection 接口
（一）概述和常用方法
Collection，接口名，含义：手机、集合
单列集合的顶层接口，定义了所有单列结合共性的功能
Collection 是接口无法创建对象，所以为了学习，我们先使用实现类 ArrayList 创建对象，进行功能的使用：接口 Collection 的引用，指向实现类 ArrayList 的对象
常用的方法：
（1）add(Object obj) ：将 obj 元素添加到集合中
（2）remove(Object obj) ：将 obj 元素从集合中删除
（3）clear() ：清空集合
（4）isEmpty() ：判断集合是否为空
（5）contains(Object obj) ：判断集合是否包含指定元素
（6）size() ：返回集合元素个数
（二）Collection的第一种遍历方法
toArray() ：将集合中的元素添加到一个数组并且返回
调用此方法，将集合元素存入数组返回数组，在对数组进行便利即可
（三）Collection 中带 All 的方法
addAll(Collection list) ：将参数集合的元素全部添加到调用者集合中
containsAll(Collection list) ：判断调用者集合中是否包含参数集合的所有元素，如果是就返回 true ，否则为 false
removeAll(Collection list) ：从调用者集合中删除和参数集合相同的那些元素
retainAll(Collection list) ：仅在调用者集合中保留和参数集合重复的元素
（四）集合的第二种遍历方式：迭代器
迭代：更迭、更新换代，从一个到另一个的过程
迭代器：专门用于将集合中的元素，一个到另一个迭代的对象
迭代器的获取：集合内部就有一个可以迭代自己的对象，我们直接从集合获取即可
调用 iterator() 方法，返回一个迭代器对象
迭代器的使用：获取到的迭代器是 Iterator 接口的实现类对象，在迭代器接口中相应的方法
（1）hasNext() 判断是否有下一个可以迭代的元素，如果有，就返回 true
（2）next() 获取集合中的下一个元素
（3）remove() 删除集合中迭代器正在遍历的那个元素
迭代器使用的注意事项：
（1）hasNext() 每次只能判断下一个元素是否存在
（2）next() 每次只能获取一个元素并且将迭代器向下一个元素移动一个位置
（3）调用一次hasNext() 就调用多次 next() 就会出现 NoSuchElementException（没有当前元素异常）
四、List 接口
（一）概述
是 Collection 的子接口
特点：
(1) 有序：元素的存储顺序和获取顺序保持一致
(2) 可重复：允许存储重复元素
(3) 可重复的原因：有索引。因为对于重复的元素，具有不同的索引来区分
特有方法：
(1) add(int index, Object obj) 将指定元素插入到集合的指定位置
(2) remove(int index) 删除指定索引上的指定元素
(3) set(int index, Object obj) 用指定元素替换指定索引上原有的元素
(4) get(int index) 返回指定索引上的元素
（三）第三种遍历方式
针对 List 集合特有的遍历方式，Collection 中不一定能用，Set 中一定不能用
可以通过 size 方法获取到集合的长度，进而就能得到 List 集合的索引范围，再配合 get 方法，就能获取到每一个索引对应的每一个元素
（四）并发修改异常
ConcurrentModificationException：并发修改异常
出现原因：在使用迭代器对象遍历集合的时候，通过集合对象操作集合
避免方式：
（1）集合遍历集合修改
（2）迭代器遍历迭代器修改
List 集合特有的迭代器：ListIterator
（1）迭代器遍历操作：和以前一样
（2）迭代增加：在ListIterator中有add方法，可以向集合中添加元素
（3）ListIterator是Iterator的子接口
（4）在List集合中要调用方法获取这个迭代器，方法：listIterator()

五、List的实现类
（一）概述
List 是一个接口，无法直接创建对象，所以根据底层实现的不同，具有不同的实现类
Vector：数组实现，顺序存储
ArrayList：数组实现，顺序存储
LinkedList：链表实现，节点存储
（二）Vector
在 JDK 1.0 版本出现，这个类已经过时，在 JDK 1.2 被 ArrayList 取代
特点：
（1）线程安全，效率低
（2）顺序存储，增删较慢
特有方法：
（1）addElement(Object obj) ：向集合中添加元素
（2）removeElement(Object obj) 删除集合中的元素
（3）elements() Vector的枚举对象（迭代器）
特有的遍历方式：
（1）使用elements方法获取Enumeration对象
（2）使用获取到的对象调用hasMoreElements方法判断是否有下一个元素
（3）使用获取到的对象调用nextElement方法获取下一个元素
（三）ArrayList
也是List接口的一个实现类
没有什么特有的方法
存储方式：
(1) 数组实现，顺序存储
(2) 增删慢，查询快
(3) 通过物理内存结构实现位置关系，来表达逻辑顺序的相临
（四）LinkedList
List接口的实现类

存储方式：
(1) 节点实现，链式存储
(2) 不是通过物理结构实现相临关系，是通过逻辑顺序实现的相临关系
(3) 每个节点中，既存储了元素，又存储了相临节点的地址，通过地址实现前后的逻辑顺序


特点
(1) 查询速度慢：需要根据前面的节点来获取后一个节点的地址，前面所有的节点都要访问一遍，节点数量越多，查询速度越慢
(2) 增删速度快：增加或者删除一个元素，只需要修改相邻接点中的地址即可

LinkedList 特有的方法：由于底层的特性，专门针对的提供了在头部尾部增删的操作：
(1) addFirst(Object obj) 将指定元素插入到列表头部
(2) addLast(Object obj) 将指定元素插入到列表尾部
(3) removeFirst() 删除头部元素并且返回
(4) removeLast() 删除尾部元素并且返回
(5) getFirst() 返回头部元素
(6) getLast() 返回尾部元素


一、泛型
（一）泛型的概述和使用
泛型：广泛的类型。在定义类的时候，某些方法的参数列表或者返回值类型不确定，就使用一个符号，来表示那些尚未确定的类型，这个符号就是泛型。
使用：对于具有泛型的类型，在类名的后面加上尖括号，尖括号里面写上泛型的确定类型（在使用某个类型创建对象的时候，对象的泛型确定为什么类型，泛型就是什么类型）例如：ArrayList list = new ArrayList();
泛型的好处：
（1）提高了数据的安全性，将运行期的问题提前暴露在了编译期
（2）避免了强转的麻烦
注意事项：
（1）泛型必须书写成引用数据类型，不能写成基本数据类型
（2）泛型书写的时候，必须保持前后一致
（3）泛型的推断：如果【=】左边的泛型已经写好，【=】右侧的泛型可以不写，会自动根据左侧的泛型确定为一样的类型。右侧直接写为【<>】，像一个菱形，所以也叫菱形泛型。JDK7的新特性
（二）泛型类的定义
泛型类：带有泛型的类
格式：
class 类名<泛型1, 泛型2, 泛型3…> {}
说明：
（1）类后面跟着的泛型类型，是泛型的声明，一旦泛型声明出来，就相当于这个类未来会有一个已知类型，这个类型就可以在类中去使用了
（2）泛型类型的声明：只要是一个合法的标识符即可，一般使用单个的大写字母表示：T（Type）、E（Element）、K（Key）、V（Value）
（3）泛型确定的时机：将来使用这个类创建对象的时候，对象的泛型必须确定为具体的类型，对象的泛型确定为什么类型，类的泛型就跟着变成什么类型
（四）泛型方法的定义
在方法的声明中，带上泛型，就是泛型方法
格式：
权限修饰符 <泛型1, 泛型2, 泛型3…> 返回值类型 方法名称(参数列表) { 方法体 }
说明：
（1）在方法上声明泛型，可以在整个方法中作为已知类型来使用
（2）如果【非静态】方法没有声明任何泛型，可以直接使用类的泛型，此时泛型就会和类泛型确定时机一样，随着对象泛型的确定而确定；如果【非静态】方法上自己定义了泛型，泛型就会随着参数的类型进行变化
（3）【静态】方法，不能使用类的泛型，如果想要使用泛型，必须自己在方法声明上定义泛型。因为类泛型随对象确定，静态优先于对象存在，静态方法使用泛型的时候，对象很可能还未创建，泛型极有可能还不确定。
（六）泛型接口的定义和使用
泛型接口：带泛型的接口
定义格式：
interface 接口名<泛型 1， 泛型 2，泛型 3…> {}
说明：
（1）在接口声明上，定义好泛型，整个接口中都可以将接口的泛型拿来使用
（2）泛型接口被其他类实现：
① 类实现接口的时候，泛型确定为了具体类型：
class 类名 implements 接口名<具体类型> {
实现接口的方法，方法使用了泛型，也都成了具体类型
}
②2) 类实现接口的时候，泛型依然不确定：
class 类名<泛型1, 泛型2…> implements 接口名<泛型1, 泛型2…> {
实现接口的方法，方法使用的泛型依然不确定
}
注意事项：累后面和接口后面的泛型符号要保持一致，表示同一个泛型；类实现接口的时候，和原接口的泛型符号可以不一样

查看类或接口的快捷键：Ctrl + shift + t
（七）泛型的通配符（了解）
符号：？
使用泛型的时候，没有使用具体的泛型声明【T】，而是使用了和T有关的类型，如果要表示和T有关的类型，就需要使用到泛型通配符【?】
第一种形式：使用?来表示可以使任意类型
在Collection中，removeAll(Collection<?> c)方法的参数，就表示可以接受任意类型泛型的集合，参数集合的泛型可以和调用者集合的泛型没有任何关系
第二种格式：？ extends E
在Collection集合中，方法addAll(Collection<? extends E> c)泛型所表示的就是：确定泛型的上边界。即：参数泛型是调用者泛型的本类或者子类，不能是父类，更不能是无关类
第四种情况：？ super E
确定泛型的下边界：表示泛型是E的父类或者是E本身，不能是E的子类，更不能是无关类。


二、Set
（一）Set 概述
Set 是 Collection 的子接口
特点：
（1）无序：存取顺序不一致
（2）不可重复：不能存储重复的元素
（3）不可重复的原因：不像 List 集合有索引可以分区区分不同元素
实现类：
（1）HashList，底层是哈希表
（2）LinkedHashList，底层是链表加哈希表
存储特点：
（1）相同元素无法存储（元素不可重复）
（2）存取顺序不一致
（二）Set集合的遍历
没有自己特有的方法，使用 Collection 中的方法蛮实用 Collection 便利的方式来遍历 Set 集合
第一种：toArray() 转数组，遍历数组
第二种：T[] toArray(T[] a) 转数组，遍历数组
（1）当数组的长度等于元素个数时，就是用提供的数组
（2）当数组的长度小于元素个数时，底层创建新的数组存储集合元素
（3）当数组长度大于元素个数时，依然使用提供的数组，但是数组剩余的部分就按照默认值填充
第三种：迭代器
第四种：增强 for 循环
（1）格式：
for(元素的数据类型 元素名称: 要遍历的集合或者数组) {
使用元素名称操作元素
}
（2）说明：增强 for 循环的底层是迭代器，如果增强 for循环遍历几个的过程中，使用了集合对象修改集合，会出现并发修改异常

三、HashSet保证元素唯一性的原理
（一）HashSet 存储 JDK 提供类型的元素
HashSet能够对JDK提供类型的元素进行有效去重
（二）HashSet 对自定义类型元素去重
实现过程：

在HashSet中存储自定义类型Person的对象
打印集合，发现自定义类型的元素没有去重
怀疑是没有重写equals方法，每一个对象的判断是按照重写前equals判断的，即按照地址判断
重写equals方法，发现依然没有去重
怀疑equals方法没有被执行，在重写的equals方法中书写显式输出打印的语句，发现确实没有被执行
怀疑还是和地址值相关
分析地址值，组成部分：全类名@十六进制数字；所有对象的全类名一样，因为来自于同一个类；@没有讨论的必要，就是一个普通的分隔符；所以问题一定处在十六进制数字
十六进制数字的由来：根据对象的真实地址，通过hashCode方法计算出哈希码值，再将哈希码值转为十六进制数字，所以：问题一定处在hashCode身上
我们不妨结合hashCode方法的常规协定三：让不同的对象具有相同的哈希码值，如果具有了相同的哈希码值，就意味着所有对象有同一个地址，这样就无法通过地址去区分不同的对象了
发现重写hashCode让所有的对象具有相同哈希码值，进而拥有相同地址值，无法通过不同的地址区分不同的对象，再次运行，equlas方法执行了，去重也实现了
（三）HashSet 保证元素唯一性原理总结
某个对象 obj ，即将要存储到 HashSet 集合的时候，首先要计算对象的哈希值
在集合中所有元素的哈希码值，都和obj的哈希码值不同，就直接将obj对象进行存储
如果集合中存在元素和obj对象的哈希值相同，并不能说明obj就在集合中存在
会进而调用equals方法判断obj对象和集合中对象是否相等
如果不相等，就对obj对象进行存储，如果相等则去重
（四）保证元素唯一性的操作
重写 HashCode 方法，让不同的对象具有相同的哈希码值，不同的对象尽量要有不同的哈希码值
重写equals方法，通过属性值来区分不同的对象
最终操作：alt + shift + s H

四、LinkedHashSet
（一）LinkedHashSet
是HashSet的一个子类，和HashSet保证元素唯一性的原理相同
和HashSet的不同之处在于：存取顺序一致
特点：有序，不可重复
应用：既要保证顺序，又要去重的时候，可以考虑使用



